
# Dockerizing "Django" with "Postgres", "Gunicorn", and "Nginx"
- This is a step-by-step tutorial that details how to configure Django
  to run on "Docker with Postgres".
  For production environments, we'll add on "Nginx and Gunicorn".
  We'll also take a look at "how to serve Django static and media files via Nginx".

  Notes:-
  - Since we'll be moving to Postgres, go ahead and remove the db.sqlite3 file from the "app" directory.
  First project directory:
```
  â””â”€â”€ app
    â”œâ”€â”€ hello_django
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ asgi.py
    â”‚   â”œâ”€â”€ settings.py
    â”‚   â”œâ”€â”€ urls.py
    â”‚   â””â”€â”€ wsgi.py
    â”œâ”€â”€ manage.py
    â””â”€â”€ requirements.txt
```

  ## Docker
  - add a "Dockerfile" to the "app" directory
  - Docker Best Practices for "Python Developers" [https://testdriven.io/blog/docker-best-practices/]

  ## Docker Compose
  - add a "docker-compose.yml" file to the project "root"
  - Check for errors in the logs if this doesn't work via docker-compose logs -f.
  - To persist the data beyond the life of the container we configured a volume. This config will bind postgres_data to the "/var/lib/postgresql/data/" directory in the container.

  CMDS:
  ```
    - docker compose build  [Build the image]
    - docker compose up -d  [run the container]
    - docker compose up -d --build  [Build the image & run the container]  [after updating main files like, requirements.txt]
    - docker compose logs -f  [Check for errors in the logs]
    - docker compose exec web python manage.py migrate --noinput  [We are working on docker ... don't think outside docker]
    - docker compose down  [to remove the container]
    - docker compose down -v  [to remove the volumes along with the containers]
    - docker compose exec db psql --username=hello_django --dbname=hello_django_dev  [Ensure the default Django tables were created]  [\l]  [\c hello_django_dev]  [\dt]
    - docker volume ls
    - docker volume inspect django-on-docker_postgres_data  [check that the volume was created as well by running]
    - docker build -f ./app/Dockerfile -t hello_django:latest ./app
    - docker compose exec web python manage.py flush --noinput
    - docker compose exec web python manage.py migrate
    - docker compose -f docker-compose.prod.yml up -d --build
    - docker compose -f docker-compose.prod.yml logs -f
    - docker compose -f docker-compose.prod.yml exec web python manage.py migrate --noinput
    - docker-compose -f docker-compose.prod.yml exec web python manage.py collectstatic --no-input --clear
  ```

  ## Update the SECRET_KEY, DEBUG, and ALLOWED_HOSTS variables in settings.py:
  - `os.environ.get("")`
  - `bool(os.environ.get("", default=0))`
  - `os.environ.get("").split(" ")`

  ## Then, create a ".env.dev" file in the project root to store environment variables for development

  ## Postgres
  - To configure Postgres, we'll need to add a new service to the "docker-compose.yml" file,
    update the Django settings, and install "Psycopg2".
  - First, add a new service called db to docker-compose.yml
  - We also added an environment key to define a name for the default database and set a username and password.

  Notes:-
  - If you run:
    ```
      - docker compose up
    ```
    - inside a folder named "django-on-docker", "Docker Compose" automatically uses that folder name as the "project name".

  Notes:-
  - Next, add an "entrypoint.sh" file to the "app" directory "to verify that Postgres is healthy"
    before applying the "migrations" and "running the Django development server":
  - Update the file permissions locally:
    `chmod +x app/entrypoint.sh`

  Notes:-
  - First, despite adding Postgres, we can still create an "independent Docker image" for "Django" as long as
    the "DATABASE environment variable" is "not set" to "postgres".

    `- docker build -f ./app/Dockerfile -t hello_django:latest ./app`
    - Uses the Dockerfile in ./app
    - Tags the image as hello_django:latest

    ```
      - docker run -d \
        -p 8006:8000 \
        -e "SECRET_KEY=please_change_me" -e "DEBUG=1" -e "DJANGO_ALLOWED_HOSTS=*" \
        hello_django python /usr/src/app/manage.py runserver 0.0.0.0:800
    ```
    - Runs the container in detached mode (-d)
    - Maps port 8000 in the container to 8006 on your host
    - Sets minimal environment variables
    - Skips DATABASE=postgres, so it wonâ€™t wait for Postgres
    - Uses Djangoâ€™s built-in dev server

    - You should be able to view the welcome page at "http://localhost:8006"

  Notes:-
    `entrypoint.prod.sh`:
    # Always remember: Update the file permissions locally:
    # `chmod +x app/entrypoint.prod.sh`


  ## Gunicorn

  Notes:-
  WSGI architecture â€” the bridge between "web servers" and "Python web apps" like Django or Flask.

  | Role                      | Real-world equivalent   | What it does                                                                             |
  |---------------------------|-------------------------|------------------------------------------------------------------------------------------|
  | You (in the metaphor)     | Gunicorn                | A Python-based web server that speaks HTTP and knows how to talk to Python apps via WSGI |
  | Client                    | Browser or API consumer | Sends HTTP requests (e.g. GET, POST)                                                     |
  | PythonApp                 | Django or Flask app     | Contains your business logic, views, models, etc.                                        |
  | WSGI                      | The protocol            | Defines how Gunicorn and PythonApp talk to each other                                    |

  ðŸ”„ The flow in real terms
  1. "Gunicorn waits" for incoming HTTP requests on a port (e.g. 8000).
  2. A "client" (like a browser or Postman) sends a request: `GET /home`.
  3. Gunicorn receives it and uses "WSGI" to pass the request to your "Django app".
  4. Django processes it â€” runs middleware, views, queries, etc.
  5. Django returns a "response" (e.g. HTML, JSON).
  6. Gunicorn sends that response back to the "client".

  Notes:-
  - If you have multiple environments, you may want to look at using a docker-compose.override.yml configuration file.
  link: [https://docs.docker.com/compose/how-tos/multiple-compose-files/extends/]

  ## Production Dockerfile


  ## Nginx
  - act as a reverse proxy for Gunicorn to handle client requests as well as serve up static files.

  - A "proxy server" is a computer networking term for a server application that acts as an
    "intermediary" between a "client requesting a resource" and the "server then providing that resource".
  - "reverse proxy server" sits in front of web servers and forwards client (e.g. web browser)
    requests to those web servers. The requested resources are then returned to the client,
    appearing as if they originated from the proxy server itself.

  updated project structure:
  ```
  â”œâ”€â”€ .env.dev
  â”œâ”€â”€ .env.prod
  â”œâ”€â”€ .env.prod.db
  â”œâ”€â”€ .gitignore
  â”œâ”€â”€ app
  â”‚   â”œâ”€â”€ Dockerfile
  â”‚   â”œâ”€â”€ Dockerfile.prod
  â”‚   â”œâ”€â”€ entrypoint.prod.sh
  â”‚   â”œâ”€â”€ entrypoint.sh
  â”‚   â”œâ”€â”€ hello_django
  â”‚   â”‚   â”œâ”€â”€ __init__.py
  â”‚   â”‚   â”œâ”€â”€ asgi.py
  â”‚   â”‚   â”œâ”€â”€ settings.py
  â”‚   â”‚   â”œâ”€â”€ urls.py
  â”‚   â”‚   â””â”€â”€ wsgi.py
  â”‚   â”œâ”€â”€ manage.py
  â”‚   â””â”€â”€ requirements.txt
  â”œâ”€â”€ docker-compose.prod.yml
  â”œâ”€â”€ docker-compose.yml
  â””â”€â”€ nginx
      â”œâ”€â”€ Dockerfile
      â””â”€â”€ nginx.conf
  ```

  Notes:-
  - Since "Gunicorn" is an application server, it will "not serve up static files".
    So, how should both "static and media files" be handled in this particular configuration?

  Notes:-
  ```
    STATIC_URL = "/static/"
    STATIC_ROOT = BASE_DIR / "staticfiles"
  ```
  - Now, any request to "http://localhost:8000/static/*" will be served from the "staticfiles" directory.

  Notes:-
  - Docker Compose normally mounts named volumes as root. And since we're using a non-root user,
    we'll get a permission denied error when the collectstatic command is run if the directory does not already exist


  ## Media Files
  - To test out the handling of media files, start by creating a new Django app:

  ## Conclusion
  - we walked through how to "containerize a Django web application" with "Postgres" for "development".
    We also created a "production-ready Docker Compose" file that adds "Gunicorn and Nginx"
    into the mix to handle "static and media files". You can now "test out a production setup locally".

  Notes:-
  - In terms of actual deployment to a production environment, you'll probably want to use a:
    1. Fully managed database service -- like "RDS" or "Cloud SQL" --
      rather than managing your own Postgres instance within a container.
    2. "Non-root" user for the "db and nginx" services
